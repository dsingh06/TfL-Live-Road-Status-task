package com.damanjit.tflliveroadstatus.networkimport com.damanjit.tflliveroadstatus.DataClassRoadStatusimport com.squareup.moshi.Moshiimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactoryimport okhttp3.OkHttpClientimport okhttp3.logging.HttpLoggingInterceptorimport retrofit2.Retrofitimport retrofit2.converter.moshi.MoshiConverterFactoryimport retrofit2.http.GETimport retrofit2.http.Path// Base URL for thr API serviceprivate const val BASE_URL = "https://api.tfl.gov.uk"// Helps debugging the Retrofit call as otherwise the comms cannot be seen between the app and serverval interceptor : HttpLoggingInterceptor = HttpLoggingInterceptor().apply {    level = HttpLoggingInterceptor.Level.BODY}// Part of the above aimval client : OkHttpClient = OkHttpClient.Builder().apply {    addInterceptor(interceptor)}.build()// JSON conversion support libraryprivate val moshi = Moshi.Builder()    .add(KotlinJsonAdapterFactory())    .build()// HTTP call support libraryprivate val retrofit = Retrofit.Builder()    .addConverterFactory(MoshiConverterFactory.create(moshi))    .baseUrl(BASE_URL)    .client(client)    .build()// Function is marked suspend because it wil be called from a coroutine inside the viewmodel class.interface TfLApiService {    @GET("/Road/{roadName}")    suspend fun getRoadStatus(@Path("roadName")roadName: String) : List<DataClassRoadStatus>}// Singleton object to be used elsewhere in the app.object TfLApi {    val retrofitService : TfLApiService by lazy {        retrofit.create(TfLApiService::class.java)    }}