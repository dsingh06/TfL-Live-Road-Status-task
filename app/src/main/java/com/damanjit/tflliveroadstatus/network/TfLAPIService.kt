package com.damanjit.tflliveroadstatus.networkimport com.damanjit.tflliveroadstatus.DataClassRoadStatusimport com.squareup.moshi.Moshiimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactoryimport okhttp3.OkHttpClientimport okhttp3.logging.HttpLoggingInterceptor//import okhttp3.OkHttpClient//import okhttp3.logging.HttpLoggingInterceptorimport retrofit2.Retrofitimport retrofit2.converter.moshi.MoshiConverterFactoryimport retrofit2.http.GETimport retrofit2.http.Pathprivate const val BASE_URL = "https://api.tfl.gov.uk"val interceptor : HttpLoggingInterceptor = HttpLoggingInterceptor().apply {    level = HttpLoggingInterceptor.Level.BODY}val client : OkHttpClient = OkHttpClient.Builder().apply {    addInterceptor(interceptor)}.build()private val moshi = Moshi.Builder()    .add(KotlinJsonAdapterFactory())    .build()private val retrofit = Retrofit.Builder()    .addConverterFactory(MoshiConverterFactory.create(moshi))    .baseUrl(BASE_URL)    .client(client)    .build()// Function is marked suspend because it wil be called from a coroutine inside the viewmodel class.interface TfLApiService {    @GET("/Road/{roadName}")    suspend fun getRoadStatus(@Path("roadName")roadName: String) : List<DataClassRoadStatus>}object TfLApi {    val retrofitService : TfLApiService by lazy {        retrofit.create(TfLApiService::class.java)    }}